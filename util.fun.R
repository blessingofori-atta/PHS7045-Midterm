
# Function to calculate the standard error of the sample mean
# Input: x - a numeric vector; na.rm - a logical value
statisticse <- function(x, na.rm = TRUE) {
  if (na.rm) {
    x <- x[!is.na(x)]
  }
  n <- length(x)
  se <- sqrt(var(x)/n)
  se
}

# Function to calculate and update the t-critical value
# Input: alpha - a numeric value indicating the significance level; 
# B - a numeric value of the number of bootstrap samples
tcrit.fun <- function(alpha, B){
  crit <- (1 - alpha) * B
  if(!is.integer(crit)){
    crit <- floor((1 - alpha) *(B + 1))
  }
  return(crit)
}


# Function to generate the bootstrap samples and calculate the bootstrap statistic theta
# theta is the function to be bootstrapped (Takes x as an argument)
# nboot is the number of bootstrap samples
# optional argument specifying the functional form of the distribution of thetahat
bootstrap <- function(x, xbar, nboot=1000, theta, ..., func = NULL){
  bsample <- matrix(sample(x, size = length(x) * nboot, replace = TRUE), nrow = nboot)
  #Calculate the bootstrap values of theta
  thetastar <- apply(bsample, 1, theta, xbar = xbar)
  return(list(
    bsample = bsample,
    thetastar = thetastar, 
    func.thetastar = if(!is.null(func)) func(thetastar) else NULL #functional form of the distribution of thetastar
  )
  )
}


# Function to calculate the symmetric bootstrap-t confidence interval
# x: vector of the original sample
# xbar: sample mean
# thetastar: bootstrap values of the statistic
# bootsamples: bootstrap samples generated by the bootstrap function
# sdfun: opt ional name of function for computing the standard deviation of theta based on data x. 
# If sdfun is missing, then symboott uses an inner bootstrap loop to estimate the standard deviation of theta(x).
# nboot: number of bootstrap samples
# nbootsd: number of bootstrap samples to estimate the standard deviation of theta(x)
# alpha: significance level
symboott <- function(x, xbar, thetastar, bootsamples, sdfun = NULL, nboot = 1000, nbootsd=25, alpha=0.05){
  #symmetric bootstrap-t method
  num <- thetastar
  cl <- parallel::makeCluster(4)
  on.exit(parallel::stopCluster(cl))  # Ensure the cluster stops when function exits
  
  if(is.null(sdfun)){
    #Make x available in the cluster
    #parallel::clusterExport(cl, c("statisticse", "x"))
    #denom <- parallel::parApply(cl, bootsamples, 1, statisticse)
    denom <- apply(bootsamples, 1, statisticse)
    
    if (any(is.na(denom))) {
      stop("Some values in denom are NA; check the statisticse function.")
    }
  } else {
    # Create a function to compute denom for parallel processing
    compute_denom <- function(i) {
      boot.sd.sample <- matrix(sample(bootsamples[i, ], size = nbootsd * length(x), replace = TRUE), nrow = nbootsd)
      boot.sd.theta <- rowMeans(boot.sd.sample)
      return(sdfun(boot.sd.theta))
    }
    
    # Parallelize the inner loop
    parallel::clusterExport(cl, c("bootsamples", "x", "sdfun", "nbootsd"), envir = environment())
    denom <- parallel::parSapply(cl, 1:nboot, compute_denom)
  }
  
  tstar <- sort(abs(num/denom))
  tcrit <- tcrit.fun(alpha, nboot)
  sdmean <- statisticse(x=x)
  c(xbar - tstar[tcrit] * sdmean, xbar + tstar[tcrit] * sdmean)
}


# Function to calculate the coverage of the confidence intervals for each of the 4 methods
cover.95 <- function(x, xbar, bootsamples, thetastar, alpha, mu){
  #symmetric bootstrap-t method with plugin estimate of standard error
  ci.symboott.plugin <- symboott(x=x, xbar=xbar, thetastar = thetastar, bootsamples = bootsamples, sdfun = NULL)
  
  #symmetric bootstrap-t method with bootstrap standard error
  ci.symboott <- symboott(x = x, xbar=xbar, thetastar = thetastar, bootsamples = bootsamples, sdfun = function(i) sd(i), nbootsd = 25)
  
  #percentile method
  ci.perc <- quantile(bootsamples, c(alpha/2, (1-alpha)/2))
  
  # #Wald method
  z <- qnorm(1 - alpha / 2)
  ci.wald <- c(xbar - z * statisticse(x=x), xbar + z * statisticse(x=x))
  
  return (
    cbind(
      cover.95_symboott_plugin = all(mu > ci.symboott.plugin[1], mu < ci.symboott.plugin[2]),
      cover.95_symboott = all(mu > ci.symboott[1], mu < ci.symboott[2]),
      cover.95_perc = all(mu > ci.perc[1], mu < ci.perc[2]),
      cover.95_wald = all(mu > ci.wald[1], mu < ci.wald[2])
    )
  )
}


# Function to simulate the x based on the true mean and true sd. 
# Then, calculate the coverage of the confidence intervals for the 4 methods
simfun <- function(sample.size){
  x.sim <- rnorm(sample.size, mean = mu, sd = sd)
  xbar.sim <- mean(x.sim, na.rm = TRUE)
  
  # Generate nboot independent bootstrap datasets
  boot.res <- bootstrap(x = x.sim, xbar=xbar.sim, theta=theta, nboot=1000)
  
  sim_cover.95 <- cover.95(
    x = x.sim,
    xbar = xbar.sim,
    bootsamples = boot.res$bsample,
    thetastar = boot.res$thetastar,
    alpha = 0.05,
    mu = mu)
  
  return(sim_cover.95)
  
}


